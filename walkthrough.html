<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NINE65 Walkthrough | HackFate</title>
    <meta name="description" content="A hands-on functional walkthrough of the NINE65 FHE system, from setup to deep circuit computation.">
    <link rel="canonical" href="https://hackfate.us/walkthrough.html">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <meta property="og:title" content="NINE65 Walkthrough | HackFate">
    <meta property="og:description" content="A hands-on functional walkthrough of the NINE65 FHE system.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://hackfate.us/walkthrough.html">
    <meta property="og:image" content="https://hackfate.us/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="HackFate - Exact Computation, Post-Quantum Security">
    <meta property="og:site_name" content="HackFate">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="NINE65 Walkthrough | HackFate">
    <meta name="twitter:description" content="A hands-on functional walkthrough of the NINE65 FHE system.">
    <meta name="twitter:image" content="https://hackfate.us/og-image.png">
    <meta name="twitter:image:alt" content="HackFate - Exact Computation, Post-Quantum Security">
    <link rel="stylesheet" href="styles.css">
</head>
<body id="top">
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <nav class="nav" aria-label="Primary">
        <div class="nav-container">
            <a href="index.html" class="nav-logo">HACKFATE</a>
            <div class="nav-links" id="nav-links">
                <a href="research.html">Research</a>
                <a href="technology.html">Technology</a>
                <a href="innovations.html">Innovations</a>
                <a href="benchmarks.html">Benchmarks</a>
                <a href="proofs.html">Proofs</a>
                <a href="nine65-saas.html">SaaS</a>
                <a href="about.html">About</a>
                <a href="contact.html" class="nav-cta">Contact</a>
            </div>
            <button class="nav-toggle" type="button" aria-label="Toggle menu" aria-controls="nav-links" aria-expanded="false">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>
    </nav>

    <section class="page-hero">
        <div class="container">
            <h1>NINE65 Functional Walkthrough</h1>
            <p>A hands-on guide to homomorphic encryption: from environment setup to deep circuit computation without bootstrapping.</p>
        </div>
    </section>

    <main id="main-content">
        <section class="section walkthrough">
            <div class="container">

                <!-- Table of Contents -->
                <div class="walkthrough-toc">
                    <h2>Contents</h2>
                    <ol>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#components">Core Functional Components</a></li>
                        <li><a href="#setup">Environment Setup</a></li>
                        <li><a href="#encryption">Basic Encryption & Decryption</a></li>
                        <li><a href="#operations">Homomorphic Operations</a></li>
                        <li><a href="#deep-circuits">Deep Circuits</a></li>
                        <li><a href="#security">Security & Error Handling</a></li>
                        <li><a href="#summary">Summary</a></li>
                    </ol>
                </div>

                <!-- Introduction -->
                <article class="walkthrough-section" id="introduction">
                    <h2>1. Introduction</h2>
                    <p>This document provides a comprehensive, hands-on walkthrough of the NINE65 Fully Homomorphic Encryption (FHE) system, with a specific focus on its <strong>fully functional capabilities</strong>. The goal is to equip developers with the practical knowledge needed to set up the FHE environment, perform core cryptographic operations, and leverage the library's unique features, such as its deep circuit capacity.</p>
                    <p>We will proceed step-by-step, from initial configuration to executing complex homomorphic computations.</p>
                </article>

                <!-- Core Components -->
                <article class="walkthrough-section" id="components">
                    <h2>2. Core Functional Components</h2>
                    <p>The following components are fully implemented, tested, and ready for use:</p>

                    <div class="component-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>Component</th>
                                    <th>Functionality</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Parameter Configuration</strong></td>
                                    <td><code>SecureConfig</code> for 128-bit and 192-bit security levels</td>
                                    <td><span class="status-badge">Fully Functional</span></td>
                                </tr>
                                <tr>
                                    <td><strong>Key Generation</strong></td>
                                    <td>Secure (CSPRNG) and deterministic key generation for <code>SecretKey</code>, <code>PublicKey</code>, and <code>EvaluationKey</code></td>
                                    <td><span class="status-badge">Fully Functional</span></td>
                                </tr>
                                <tr>
                                    <td><strong>Encoding/Decoding</strong></td>
                                    <td><code>BFVEncoder</code> for converting integer messages into plaintext polynomials</td>
                                    <td><span class="status-badge">Fully Functional</span></td>
                                </tr>
                                <tr>
                                    <td><strong>Encryption/Decryption</strong></td>
                                    <td><code>BFVEncryptor</code> and <code>BFVDecryptor</code> for both symmetric and asymmetric encryption</td>
                                    <td><span class="status-badge">Fully Functional</span></td>
                                </tr>
                                <tr>
                                    <td><strong>Error Handling</strong></td>
                                    <td>Robust <code>Result</code>-based error handling (<code>Nine65Error</code>)</td>
                                    <td><span class="status-badge">Fully Functional</span></td>
                                </tr>
                                <tr>
                                    <td><strong>Homomorphic Addition</strong></td>
                                    <td><code>BFVEvaluator::add</code> for ciphertext-ciphertext addition</td>
                                    <td><span class="status-badge">Fully Functional</span></td>
                                </tr>
                                <tr>
                                    <td><strong>Homomorphic Subtraction</strong></td>
                                    <td><code>BFVEvaluator::sub</code> for ciphertext-ciphertext subtraction</td>
                                    <td><span class="status-badge">Fully Functional</span></td>
                                </tr>
                                <tr>
                                    <td><strong>Homomorphic Multiplication</strong></td>
                                    <td><code>BFVEvaluator::mul</code> and <code>relinearize</code> for ciphertext multiplication</td>
                                    <td><span class="status-badge">Fully Functional</span></td>
                                </tr>
                                <tr>
                                    <td><strong>Deep Circuits (Symmetric)</strong></td>
                                    <td>Multi-level consecutive multiplications without bootstrapping</td>
                                    <td><span class="status-badge">Fully Functional</span></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <!-- Environment Setup -->
                <article class="walkthrough-section" id="setup">
                    <h2>3. Environment Setup</h2>
                    <p>First, we must configure the FHE environment. This involves selecting a security level and initializing the necessary cryptographic engines and context objects.</p>

                    <div class="callout callout-security">
                        <strong>Security Note:</strong> For any production use, always start with a <code>SecureConfig</code>. The <code>secure_128()</code> preset provides a 128-bit classical security level, compliant with the <a href="https://homomorphicencryption.org/" target="_blank" rel="noopener">Homomorphic Encryption Standard</a>.
                    </div>

                    <pre><code class="language-rust">use nine65::prelude::*;

// 1. Select a production-ready, 128-bit secure parameter set.
let config = SecureConfig::secure_128().into_config();

// 2. Initialize the NTT (Number Theoretic Transform) engine, which is crucial
//    for efficient polynomial multiplication.
let ntt = NTTEngine::new(config.q, config.n);

// 3. For this walkthrough, we use a deterministic Random Number Generator (RNG)
//    to ensure the examples are reproducible. In production, you MUST use
//    `KeySet::generate_secure(&config, &ntt)` which uses the OS's secure RNG.
let mut rng = ShadowHarvester::with_seed(42);

// 4. Generate the complete set of keys: secret, public, and evaluation keys.
let keys = KeySet::generate(&config, &ntt, &mut rng);

// 5. Instantiate the core FHE components using the generated keys and config.
let encoder = BFVEncoder::new(&config);
let encryptor = BFVEncryptor::new(&keys.public_key, &encoder, &ntt, config.eta);
let decryptor = BFVDecryptor::new(&keys.secret_key, &encoder, &ntt);
let evaluator = BFVEvaluator::new(&ntt, &encoder, Some(&keys.eval_key));

println!("FHE Environment Initialized Successfully!");</code></pre>
                </article>

                <!-- Basic Encryption -->
                <article class="walkthrough-section" id="encryption">
                    <h2>4. Basic Encryption & Decryption</h2>
                    <p>The most fundamental workflow is the encryption of a plaintext message, followed by its decryption. This confirms that the keys and parameters are configured correctly.</p>

                    <pre><code class="language-rust">// Assume the setup from Step 1 is complete.
let message = 12345u64;

// Encrypt the message using the public key and the deterministic RNG.
let ciphertext = encryptor.encrypt(message, &mut rng);

// Decrypt the resulting ciphertext using the secret key.
let decrypted_message = decryptor.decrypt(&ciphertext);

println!("Original Message: {}", message);
println!("Decrypted Message: {}", decrypted_message);

assert_eq!(message, decrypted_message);
println!("Encryption/Decryption Roundtrip Successful!");</code></pre>
                </article>

                <!-- Homomorphic Operations -->
                <article class="walkthrough-section" id="operations">
                    <h2>5. Homomorphic Operations</h2>
                    <p>With the setup confirmed, we can now perform computations directly on encrypted data.</p>

                    <h3>Addition and Subtraction</h3>
                    <p>These are the simplest homomorphic operations and have a very low impact on the noise within the ciphertext.</p>

                    <pre><code class="language-rust">// Encrypt two separate messages.
let m1 = 100u64;
let m2 = 25u64;
let ct1 = encryptor.encrypt(m1, &mut rng);
let ct2 = encryptor.encrypt(m2, &mut rng);

// Perform homomorphic addition.
let ct_sum = evaluator.add(&ct1, &ct2);
let sum_result = decryptor.decrypt(&ct_sum);
println!("Homomorphic Addition: {} + {} = {}", m1, m2, sum_result);
assert_eq!(sum_result, m1 + m2);

// Perform homomorphic subtraction.
let ct_diff = evaluator.sub(&ct1, &ct2);
let diff_result = decryptor.decrypt(&ct_diff);
println!("Homomorphic Subtraction: {} - {} = {}", m1, m2, diff_result);
assert_eq!(diff_result, m1 - m2);</code></pre>

                    <h3>Multiplication</h3>
                    <p>Homomorphic multiplication is the most powerful and noise-intensive operation. After each multiplication, a <code>relinearize</code> step is required. This step uses the <code>EvaluationKey</code> to reduce the size of the resulting ciphertext back to its original form, making it suitable for further operations.</p>

                    <pre><code class="language-rust">let m3 = 7u64;
let m4 = 8u64;
let ct3 = encryptor.encrypt(m3, &mut rng);
let ct4 = encryptor.encrypt(m4, &mut rng);

// Perform homomorphic multiplication. This operation returns a `Result`.
let ct_prod_large = evaluator.mul(&ct3, &ct4).unwrap();

// Relinearize the resulting ciphertext to reduce its size and make it usable.
let ct_prod_relin = evaluator.relinearize(&ct_prod_large).unwrap();

let prod_result = decryptor.decrypt(&ct_prod_relin);
println!("Homomorphic Multiplication: {} * {} = {}", m3, m4, prod_result);
assert_eq!(prod_result, m3 * m4);</code></pre>
                </article>

                <!-- Deep Circuits -->
                <article class="walkthrough-section" id="deep-circuits">
                    <h2>6. Deep Circuits (Symmetric Mode)</h2>
                    <p>NINE65's flagship capability is executing deep computational graphs <strong>without bootstrapping</strong>. This functionality is fully operational and most effective in <strong>symmetric encryption mode</strong>. In this mode, the <code>SecretKey</code> is used for both encryption and decryption, which is ideal for scenarios where the data owner is also performing the computation.</p>

                    <p>This example calculates <code>3<sup>16</sup></code> homomorphically, a task that requires a multiplicative depth of 4 and would necessitate bootstrapping in most other FHE libraries.</p>

                    <pre><code class="language-rust">// 1. Create a new encryptor that uses the secret key (symmetric mode).
let symmetric_encryptor = BFVEncryptor::new_symmetric(
    &keys.secret_key, &encoder, &ntt, config.eta
);

// 2. Encrypt the base number.
let base = 3u64;
let mut ct_power = symmetric_encryptor.encrypt(base, &mut rng);

// 3. Perform 4 consecutive squaring operations (multiplications).
println!("Calculating 3^16 homomorphically...");
for i in 1..=4 {
    let ct_squared = evaluator.mul(&ct_power, &ct_power).unwrap();
    ct_power = evaluator.relinearize(&ct_squared).unwrap();

    let power = 2u64.pow(i + 1);
    let current_val = decryptor.decrypt(&ct_power);
    println!("  Depth {}: Homomorphic result for 3^{} = {}", i, power, current_val);
}

// 4. Verify the final result.
let final_result = decryptor.decrypt(&ct_power);
let expected_result = (3u128.pow(16) % config.t as u128) as u64;

println!("Final Homomorphic Result: {}", final_result);
println!("Expected Result: {}", expected_result);

assert_eq!(final_result, expected_result);
println!("Deep circuit (depth 4) computed successfully!");</code></pre>

                    <div class="callout callout-info">
                        <strong>Key Insight:</strong> Traditional FHE libraries require costly bootstrapping operations (100-1000ms each) to handle deep circuits. NINE65's exact arithmetic approach allows depth-4 computations to complete without any bootstrapping overhead.
                    </div>
                </article>

                <!-- Security -->
                <article class="walkthrough-section" id="security">
                    <h2>7. Security & Error Handling</h2>
                    <p>NINE65's API is designed to guide developers toward secure and robust implementations.</p>

                    <h3>Secure Methods</h3>
                    <p>For production, always use methods with a <code>_secure</code> suffix (e.g., <code>encrypt_secure</code>, <code>generate_secure</code>). These methods are guaranteed to use a cryptographically secure random number generator (CSPRNG) from the underlying operating system.</p>

                    <h3>Fallible Operations</h3>
                    <p>Any operation that can potentially fail (e.g., encoding a message that is too large) returns a <code>Nine65Result&lt;T&gt;</code>. This enforces explicit error handling and prevents unexpected panics.</p>

                    <pre><code class="language-rust">// Attempt to encode a message that is larger than the plaintext modulus `t`.
let large_message = config.t + 1;
let encode_result = encoder.try_encode(large_message);

match encode_result {
    Ok(_) => panic!("This should have failed!"),
    Err(Nine65Error::MessageOutOfBounds { message, modulus }) => {
        println!("Correctly caught expected error: Message {} is out of bounds for modulus {}.",
                 message, modulus);
    }
    Err(e) => panic!("Caught an unexpected error type: {:?}", e),
}</code></pre>
                </article>

                <!-- Summary -->
                <article class="walkthrough-section" id="summary">
                    <h2>8. Summary</h2>
                    <p>This walkthrough has demonstrated the core, fully functional capabilities of the NINE65 FHE library. Developers can confidently use the system for:</p>

                    <ul class="summary-list">
                        <li><strong>Setting up</strong> a secure FHE environment with 128-bit+ security</li>
                        <li><strong>Performing</strong> basic encryption, decryption, addition, subtraction, and multiplication</li>
                        <li><strong>Executing</strong> deep, multi-level homomorphic computations in symmetric mode without bootstrapping</li>
                        <li><strong>Implementing</strong> robust applications with built-in secure defaults and comprehensive error handling</li>
                    </ul>

                    <p>The primary limitation to be aware of is that the deep circuit capability is currently optimized for <strong>symmetric mode</strong>. Public key operations are fully functional but are best suited for shallower circuits with the existing parameter sets.</p>

                    <p>NINE65 provides a powerful and efficient toolset for privacy-preserving computation, offering a unique and practical solution for deep circuit evaluation on standard CPU hardware.</p>

                    <div class="cta-section">
                        <h3>Ready to Learn More?</h3>
                        <div class="cta-buttons">
                            <a href="technology.html" class="btn btn-primary">Explore Technology</a>
                            <a href="innovations.html" class="btn btn-secondary">View Innovations</a>
                            <a href="contact.html" class="btn btn-secondary">Request Access</a>
                        </div>
                    </div>
                </article>

                <!-- References -->
                <article class="walkthrough-section" id="references">
                    <h2>References</h2>
                    <ol class="references-list">
                        <li>Homomorphic Encryption Standardization. (2024). <em>Homomorphic Encryption Standard</em>. <a href="https://homomorphicencryption.org/" target="_blank" rel="noopener">https://homomorphicencryption.org/</a></li>
                        <li>Ahmad, J., et al. (2025). <em>Cross-Platform Benchmarking of the FHE Libraries</em>. ePrint Archive. <a href="https://eprint.iacr.org/2025/473" target="_blank" rel="noopener">https://eprint.iacr.org/2025/473</a></li>
                        <li>Pambudi, D. S., et al. (2025). <em>A Benchmark Study of SEAL, HElib, OpenFHE, and Lattigo</em>. ACM Digital Library. <a href="https://dl.acm.org/doi/10.1145/3729706.3729711" target="_blank" rel="noopener">https://dl.acm.org/doi/10.1145/3729706.3729711</a></li>
                    </ol>
                </article>

            </div>
        </section>
    </main>

    <a href="#top" class="back-to-top" aria-label="Back to top">Top</a>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-brand">
                    <span class="footer-logo">HACKFATE</span>
                    <p>"Truth cannot be approximated."</p>
                </div>
                <div class="footer-links">
                    <a href="research.html">Research</a>
                    <a href="technology.html">Technology</a>
                    <a href="innovations.html">Innovations</a>
                    <a href="benchmarks.html">Benchmarks</a>
                    <a href="walkthrough.html">Walkthrough</a>
                    <a href="nine65-saas.html">SaaS</a>
                    <a href="about.html">About</a>
                    <a href="contact.html">Contact</a>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2026 Anthony Diaz. All rights reserved.</p>
                <p>Proprietary technology protected. Public research available under respective licenses.</p>
                <p><a href="privacy.html" class="footer-legal-link">Privacy Policy</a></p>
            </div>
        </div>
    </footer>

    <script defer src="script.js"></script>
</body>
</html>
